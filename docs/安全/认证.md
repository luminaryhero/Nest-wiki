èº«ä»½éªŒè¯æ˜¯å¤§å¤šæ•°åº”ç”¨ç¨‹åºçš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚æœ‰è®¸å¤šä¸åŒçš„æ–¹æ³•å’Œç­–ç•¥æ¥å¤„ç†èº«ä»½éªŒè¯ã€‚ä»»ä½•é¡¹ç›®æ‰€é‡‡ç”¨çš„æ–¹æ³•éƒ½å–å†³äºå…¶ç‰¹å®šçš„åº”ç”¨è¦æ±‚ã€‚æœ¬ç« ä»‹ç»äº†å‡ ç§èº«ä»½éªŒè¯æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•å¯ä»¥é€‚åº”å„ç§ä¸åŒçš„è¦æ±‚ã€‚

è®©æˆ‘ä»¬å……å®æˆ‘ä»¬çš„è¦æ±‚ã€‚å¯¹äºæ­¤ç”¨ä¾‹ï¼Œå®¢æˆ·ç«¯å°†é¦–å…ˆä½¿ç”¨ç”¨æˆ·åå’Œå¯†ç è¿›è¡Œèº«ä»½éªŒè¯ã€‚é€šè¿‡èº«ä»½éªŒè¯åï¼ŒæœåŠ¡å™¨å°†å‘å‡ºä¸€ä¸ª JWTï¼Œè¯¥ JWT å¯ä»¥åœ¨åç»­è¯·æ±‚çš„æˆæƒæ ‡å¤´ä¸­ä½œä¸ºæŒæœ‰è€…ä»¤ç‰Œå‘é€ï¼Œä»¥è¯æ˜èº«ä»½éªŒè¯ã€‚æˆ‘ä»¬è¿˜å°†åˆ›å»ºä¸€ä¸ªå—ä¿æŠ¤çš„è·¯ç”±ï¼Œè¯¥è·¯ç”±åªèƒ½ç”±åŒ…å«æœ‰æ•ˆ JWT çš„è¯·æ±‚è®¿é—®ã€‚

æˆ‘ä»¬å°†ä»ç¬¬ä¸€ä¸ªè¦æ±‚å¼€å§‹ï¼šå¯¹ç”¨æˆ·è¿›è¡Œèº«ä»½éªŒè¯ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†é€šè¿‡å‘å¸ƒ JWT æ¥æ‰©å±•å®ƒã€‚æœ€åï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªå—ä¿æŠ¤çš„è·¯ç”±ï¼Œç”¨äºæ£€æŸ¥è¯·æ±‚ä¸Šçš„æœ‰æ•ˆ JWTã€‚



## åˆ›å»ºèº«ä»½éªŒè¯æ¨¡å—

æˆ‘ä»¬å°†é¦–å…ˆåœ¨å…¶ä¸­ç”Ÿæˆä¸€ä¸ª andã€ä¸€ä¸ª `AuthModule` `AuthService` å’Œä¸€ä¸ª `AuthController` .æˆ‘ä»¬å°†ä½¿ç”¨ æ¥å®ç° `AuthService` èº«ä»½éªŒè¯é€»è¾‘ï¼Œå¹¶ä½¿ç”¨ `AuthController` å…¬å¼€èº«ä»½éªŒè¯ç»ˆç»“ç‚¹ã€‚

```bash
$ nest g module auth
$ nest g controller auth
$ nest g service auth
```

å½“æˆ‘ä»¬å®ç° `AuthService` æ—¶ï¼Œæˆ‘ä»¬ä¼šå‘ç°å°†ç”¨æˆ·æ“ä½œå°è£…åœ¨ `UsersService` ä¸­å¾ˆæœ‰ç”¨ï¼Œæ‰€ä»¥ç°åœ¨è®©æˆ‘ä»¬ç”Ÿæˆè¯¥æ¨¡å—å’ŒæœåŠ¡ï¼š

```bash
$ nest g module users
$ nest g service users
```

æ›¿æ¢è¿™äº›ç”Ÿæˆçš„æ–‡ä»¶çš„é»˜è®¤å†…å®¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚å¯¹äºæˆ‘ä»¬çš„ç¤ºä¾‹åº”ç”¨ï¼Œåªéœ€ `UsersService` ç»´æŠ¤ä¸€ä¸ªç¡¬ç¼–ç çš„å†…å­˜ä¸­ç”¨æˆ·åˆ—è¡¨ï¼Œä»¥åŠä¸€ä¸ªæŒ‰ç”¨æˆ·åæ£€ç´¢ç”¨æˆ·çš„ find æ–¹æ³•ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨æ‚¨é€‰æ‹©çš„åº“ï¼ˆä¾‹å¦‚ TypeORMã€Sequelizeã€Mongoose ç­‰ï¼‰æ„å»ºç”¨æˆ·æ¨¡å‹å’ŒæŒä¹…å±‚ã€‚

> users/users.service.ts

```typescript
import { Injectable } from '@nestjs/common';

// This should be a real class/interface representing a user entity
export type User = any;

@Injectable()
export class UsersService {
  private readonly users = [
    {
      userId: 1,
      username: 'john',
      password: 'changeme',
    },
    {
      userId: 2,
      username: 'maria',
      password: 'guess',
    },
  ];

  async findOne(username: string): Promise<User | undefined> {
    return this.users.find(user => user.username === username);
  }
}
```

åœ¨ `UsersModule` ä¸­ï¼Œå”¯ä¸€éœ€è¦çš„æ›´æ”¹æ˜¯å°† `UsersService` æ·»åŠ åˆ° `@Module` è£…é¥°å™¨çš„ exports æ•°ç»„ä¸­ï¼Œä»¥ä¾¿å®ƒåœ¨æ­¤æ¨¡å—ä¹‹å¤–å¯è§ï¼ˆæˆ‘ä»¬å¾ˆå¿«å°±ä¼šåœ¨æˆ‘ä»¬çš„ `AuthService` ä¸­ä½¿ç”¨å®ƒï¼‰ã€‚



#### å®ç°â€œç™»å½•â€ç»ˆç»“ç‚¹

æˆ‘ä»¬çš„ `AuthService` å·¥ä½œæ˜¯æ£€ç´¢ç”¨æˆ·å¹¶éªŒè¯å¯†ç ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª `signIn()` æ–¹æ³•ã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªæ–¹ä¾¿çš„ ES6 æ‰©å±•è¿ç®—ç¬¦åœ¨è¿”å›ä¹‹å‰ä»ç”¨æˆ·å¯¹è±¡ä¸­å‰¥ç¦» password å±æ€§ã€‚è¿™æ˜¯è¿”å›ç”¨æˆ·å¯¹è±¡æ—¶çš„å¸¸è§åšæ³•ï¼Œå› ä¸ºæ‚¨ä¸å¸Œæœ›å…¬å¼€æ•æ„Ÿå­—æ®µï¼Œå¦‚å¯†ç æˆ–å…¶ä»–å®‰å…¨å¯†é’¥ã€‚

> auth/auth.service.ts

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { UsersService } from '../users/users.service';

@Injectable()
export class AuthService {
  constructor(private usersService: UsersService) {}

  async signIn(username: string, pass: string): Promise<any> {
    const user = await this.usersService.findOne(username);
    if (user?.password !== pass) {
      throw new UnauthorizedException();
    }
    const { password, ...result } = user;
    // TODO: Generate a JWT and return it here
    // instead of the user object
    return result;
  }
}
```

ç°åœ¨ï¼Œæˆ‘ä»¬æ›´æ–°æˆ‘ä»¬çš„ `AuthModule` `UsersModule` å¯¼å…¥ .

> auth/auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [UsersModule],
  providers: [AuthService],
  controllers: [AuthController],
})
export class AuthModule {}
```

æœ‰äº†è¿™ä¸ªï¼Œè®©æˆ‘ä»¬æ‰“å¼€ å¹¶å‘ `AuthController` å…¶æ·»åŠ ä¸€ä¸ª `signIn()` æ–¹æ³•ã€‚å®¢æˆ·ç«¯å°†è°ƒç”¨æ­¤æ–¹æ³•æ¥å¯¹ç”¨æˆ·è¿›è¡Œèº«ä»½éªŒè¯ã€‚å®ƒå°†åœ¨è¯·æ±‚æ­£æ–‡ä¸­æ¥æ”¶ç”¨æˆ·åå’Œå¯†ç ï¼Œå¦‚æœç”¨æˆ·å·²é€šè¿‡èº«ä»½éªŒè¯ï¼Œå®ƒå°†è¿”å› JWT ä»¤ç‰Œã€‚

> auth/auth.controller.ts

```typescript
import { Body, Controller, Post, HttpCode, HttpStatus } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  signIn(@Body() signInDto: Record<string, any>) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }
}
```



## JWT token

æˆ‘ä»¬éœ€è¦å®‰è£…ä¸€ä¸ªé¢å¤–çš„åŒ…æ¥æ”¯æŒæˆ‘ä»¬çš„ JWT è¦æ±‚ï¼š

```bash
$ npm install --save @nestjs/jwt
```

ä¸ºäº†ä¿æŒæˆ‘ä»¬çš„æœåŠ¡å®Œå…¨æ¨¡å—åŒ–ï¼Œæˆ‘ä»¬å°†åœ¨ . `authService` æ‰“å¼€æ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶ `auth.service.ts` ï¼Œæ³¨å…¥ `JwtService` ï¼Œå¹¶æ›´æ–° `signIn` ç”Ÿæˆ JWT ä»¤ç‰Œçš„æ–¹æ³•ï¼Œ `auth` å¦‚ä¸‹æ‰€ç¤ºï¼š

> auth/auth.service.ts

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async signIn(username, pass) {
    const user = await this.usersService.findOne(username);
    if (user?.password !== pass) {
      throw new UnauthorizedException();
    }
    const payload = { sub: user.userId, username: user.username };
    return {
      access_token: await this.jwtService.signAsync(payload),
    };
  }
}
```

æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯è¯¥ `@nestjs/jwt` åº“ï¼Œå®ƒæä¾›äº†ä¸€ä¸ª `signAsync()` å‡½æ•°ï¼Œç”¨äºä»å¯¹è±¡å±æ€§çš„å­é›†ç”Ÿæˆ JWTï¼Œç„¶åæˆ‘ä»¬å°†å…¶ä½œä¸ºå…·æœ‰å•ä¸ª `access_token` å±æ€§çš„ç®€å• `user` å¯¹è±¡è¿”å›ã€‚æ³¨æ„ï¼šæˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªå±æ€§åç§°æ¥ `sub` ä¿æŒæˆ‘ä»¬çš„ `userId` å€¼ä¸ JWT æ ‡å‡†ä¸€è‡´ã€‚ä¸è¦å¿˜è®°å°† JwtService æä¾›ç¨‹åºæ³¨å…¥åˆ° `AuthService` .

æˆ‘ä»¬ç°åœ¨éœ€è¦æ›´æ–° å¯¼å…¥ `AuthModule` æ–°çš„ä¾èµ–é¡¹å¹¶é…ç½® `JwtModule` .

é¦–å…ˆï¼Œåœ¨ `auth` æ–‡ä»¶å¤¹ä¸­åˆ›å»º `constants.ts` ï¼Œå¹¶æ·»åŠ ä»¥ä¸‹ä»£ç ï¼š

> auth/constants.ts

```typescript
export const jwtConstants = {
  secret: 'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
};
```

æˆ‘ä»¬å°†ä½¿ç”¨å®ƒåœ¨ JWT ç­¾åå’ŒéªŒè¯æ­¥éª¤ä¹‹é—´å…±äº«å¯†é’¥ã€‚

ç°åœ¨ï¼Œåœ¨ `auth` æ–‡ä»¶å¤¹ä¸­æ‰“å¼€ `auth.module.ts` å¹¶å°†å…¶æ›´æ–°ä¸ºå¦‚ä¸‹æ‰€ç¤ºï¼š

> auth/auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { JwtModule } from '@nestjs/jwt';
import { AuthController } from './auth.controller';
import { jwtConstants } from './constants';

@Module({
  imports: [
    UsersModule,
    JwtModule.register({
      global: true,
      secret: jwtConstants.secret,
      signOptions: { expiresIn: '60s' },
    }),
  ],
  providers: [AuthService],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}
```

è®©æˆ‘ä»¬ç»§ç»­ä½¿ç”¨ cURL å†æ¬¡æµ‹è¯•æˆ‘ä»¬çš„è·¯ç”±ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ `UsersService` ä¸­ç¡¬ç¼–ç çš„ä»»ä½• `user` å¯¹è±¡è¿›è¡Œæµ‹è¯•ã€‚

```bash
$ # POST to /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
$ # Note: above JWT truncated
```



## å®ç°èº«ä»½éªŒè¯é˜²æŠ¤

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥æ»¡è¶³æˆ‘ä»¬çš„æœ€åä¸€ä¸ªè¦æ±‚ï¼šé€šè¿‡è¦æ±‚è¯·æ±‚ä¸­å­˜åœ¨æœ‰æ•ˆçš„ JWT æ¥ä¿æŠ¤ç«¯ç‚¹ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª `AuthGuard` å¯ç”¨äºä¿æŠ¤è·¯ç”±çš„å·¥å…·ã€‚

> auth/auth.guard.ts

```typescript
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { jwtConstants } from './constants';
import { Request } from 'express';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    if (!token) {
      throw new UnauthorizedException();
    }
    try {
      const payload = await this.jwtService.verifyAsync(
        token,
        {
          secret: jwtConstants.secret
        }
      );
      // ğŸ’¡ We're assigning the payload to the request object here
      // so that we can access it in our route handlers
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException();
    }
    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°å—ä¿æŠ¤çš„è·¯ç”±å¹¶æ³¨å†Œæˆ‘ä»¬çš„ `AuthGuard` è·¯ç”±æ¥ä¿æŠ¤å®ƒã€‚

> auth.controller.ts

```typescript
import {
  Body,
  Controller,
  Get,
  HttpCode,
  HttpStatus,
  Post,
  Request,
  UseGuards
} from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  signIn(@Body() signInDto: Record<string, any>) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }

  @UseGuards(AuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}
```

æˆ‘ä»¬æ­£åœ¨å°†åˆšåˆšåˆ›å»ºçš„è·¯ç”±åº”ç”¨äº `AuthGuard` è·¯ç”±ï¼Œ `GET /profile` ä»¥ä¾¿å¯¹å…¶è¿›è¡Œä¿æŠ¤ã€‚

ç¡®ä¿åº”ç”¨ç¨‹åºæ­£åœ¨è¿è¡Œï¼Œå¹¶ä½¿ç”¨ `cURL` æµ‹è¯•è·¯ç”±ã€‚

```bash
$ # GET /profile
$ curl http://localhost:3000/auth/profile
{"statusCode":401,"message":"Unauthorized"}

$ # POST /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."}

$ # GET /profile using access_token returned from previous step as bearer code
$ curl http://localhost:3000/auth/profile -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."
{"sub":1,"username":"john","iat":...,"exp":...}
```

è¯·æ³¨æ„ï¼Œåœ¨ `AuthModule` ä¸­ï¼Œæˆ‘ä»¬å°† JWT é…ç½®ä¸º `60 seconds` .æ­¤è¿‡æœŸæ—¶é—´å¤ªçŸ­ï¼Œå¤„ç†ä»¤ç‰Œè¿‡æœŸå’Œåˆ·æ–°çš„è¯¦ç»†ä¿¡æ¯è¶…å‡ºäº†æœ¬æ–‡çš„èŒƒå›´ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬é€‰æ‹©å®ƒæ¥å±•ç¤º JWT çš„é‡è¦å“è´¨ã€‚å¦‚æœæ‚¨åœ¨èº«ä»½éªŒè¯åç­‰å¾… 60 ç§’ï¼Œç„¶åå†å°è¯•è¯·æ±‚ `GET /auth/profile` ï¼Œæ‚¨å°†æ”¶åˆ°å“åº” `401 Unauthorized` ã€‚è¿™æ˜¯å› ä¸º `@nestjs/jwt` ä¼šè‡ªåŠ¨æ£€æŸ¥ JWT çš„è¿‡æœŸæ—¶é—´ï¼Œä»è€Œçœå»äº†åœ¨åº”ç”¨ç¨‹åºä¸­æ‰§è¡Œæ­¤æ“ä½œçš„éº»çƒ¦ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº† JWT èº«ä»½éªŒè¯çš„å®ç°ã€‚JavaScript å®¢æˆ·ç«¯ï¼ˆå¦‚ Angular/React/Vueï¼‰å’Œå…¶ä»– JavaScript åº”ç”¨ç¨‹åºç°åœ¨å¯ä»¥ä¸æˆ‘ä»¬çš„ API æœåŠ¡å™¨è¿›è¡Œèº«ä»½éªŒè¯å’Œå®‰å…¨é€šä¿¡ã€‚



## å…¨å±€å¯ç”¨èº«ä»½éªŒè¯

å¦‚æœé»˜è®¤æƒ…å†µä¸‹åº”ä¿æŠ¤ç»å¤§å¤šæ•°ç»ˆç»“ç‚¹ï¼Œåˆ™å¯ä»¥å°†èº«ä»½éªŒè¯é˜²æŠ¤æ³¨å†Œä¸ºå…¨å±€é˜²æŠ¤ï¼Œè€Œä¸æ˜¯åœ¨æ¯ä¸ªæ§åˆ¶å™¨é¡¶éƒ¨ä½¿ç”¨ `@UseGuards()` è£…é¥°å™¨ï¼Œåªéœ€æ ‡è®°å“ªäº›è·¯ç”±åº”ä¸ºå…¬å…±è·¯ç”±å³å¯ã€‚

é¦–å…ˆï¼Œä½¿ç”¨ä»¥ä¸‹æ„é€ å°† æ³¨å†Œ `AuthGuard` ä¸ºå…¨å±€å®ˆå«ï¼ˆåœ¨ä»»ä½•æ¨¡å—ä¸­ï¼Œä¾‹å¦‚ï¼Œåœ¨ `AuthModule` ï¼‰ï¼š

```typescript
providers: [
  {
    provide: APP_GUARD,
    useClass: AuthGuard,
  },
],
```

è¿™æ ·ï¼ŒNest å°†è‡ªåŠ¨ç»‘å®š `AuthGuard` åˆ°æ‰€æœ‰ç«¯ç‚¹ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å¿…é¡»æä¾›ä¸€ç§å°†è·¯ç”±å£°æ˜ä¸ºå…¬å…±è·¯ç”±çš„æœºåˆ¶ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `SetMetadata` decorator factory å‡½æ•°åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰è£…é¥°å™¨ã€‚

```typescript
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

ç°åœ¨æˆ‘ä»¬æœ‰äº†è‡ªå®šä¹‰ `@Public()` è£…é¥°å™¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥è£…é¥°ä»»ä½•æ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```typescript
@Public()
@Get()
findAll() {
  return [];
}
```

æœ€åï¼Œæˆ‘ä»¬éœ€è¦åœ¨ `AuthGuard` æ‰¾åˆ° `"isPublic"` å…ƒæ•°æ®æ—¶è¿”å› `true` ã€‚

```typescript
@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private jwtService: JwtService, private reflector: Reflector) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      // ğŸ’¡ See this condition
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    if (!token) {
      throw new UnauthorizedException();
    }
    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: jwtConstants.secret,
      });
      // ğŸ’¡ We're assigning the payload to the request object here
      // so that we can access it in our route handlers
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException();
    }
    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```



## Passporté›†æˆ

Passport æ˜¯æœ€æµè¡Œçš„ node.js è®¤è¯åº“ï¼Œä¸ºç¤¾åŒºæ‰€ç†ŸçŸ¥ï¼Œå¹¶æˆåŠŸç”¨äºè®¸å¤šç”Ÿäº§åº”ç”¨ç¨‹åºã€‚ä½¿ç”¨è¯¥ `@nestjs/passport` æ¨¡å—å°†æ­¤åº“ä¸ Nest åº”ç”¨ç¨‹åºé›†æˆéå¸¸ç®€å•ã€‚



> æ›´å¤šè¯¦ç»†ä¿¡æ¯è¯·è®¿é—®å®˜ç½‘ï¼šhttps://docs.nestjs.com/security/authentication